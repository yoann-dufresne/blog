<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <title>Yet Another Bioinformatic blog</title>

    <!-- css -->
    <link rel="stylesheet" href="/cayman.css">
    <link rel="stylesheet" href="/add.css">

    <!-- font -->
    <link rel="stylesheet" href="/fonts/fork_awesome/css/fork-awesome.min.css">
    <link rel="stylesheet" href="/fonts/academicons/css/academicons.min.css">
    
    <!-- js -->

    
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https:&#x2F;&#x2F;blog.pierre.marijon.fr&#x2F;rss.xml">
    

    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML'>  
</script>

<script>
MathJax.Hub.Config({
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
	inlineMath: [['$', '$']],
	displayMath: [['$$', '$$'],['\\[','\\]']],
	processEscapes: true,
	skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    messageStyle: "none",
    "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
    TeX: {
	equationNumbers: { autoNumber: "AMS" },
	extensions: ["AMSmath.js", "AMSsymbols.js","AMScd.js"],
	TagSide: "left",
	Macros: {
	    field: ['\\mathbb{#1}', 1],
	    C: ['\\field{C}'],
	    F: ['\\field{F}'],
	    N: ['\\field{N}'],
	    Q: ['\\field{Q}'],
	    R: ['\\field{R}'],
	    Z: ['\\field{Z}'],

	    zeros: ['\\mathbf{0}'],
	    ud: ['\\,\\mathrm{d}'],

	    vect:['\\boldsymbol{\\mathbf{#1}}',1],
	    abs: ['\\lvert#1\\rvert', 1],
	    abslr:['\\left\\lvert#1\\right\\rvert', 1],
	    norm: ['\\lVert#1\\rVert', 1],
	    normlr: ['\\left\\lVert#1\\right\\rVert', 1],

	    lcm: ['\\mathop{\\mathrm{lcm}}'],
	    interior: ['\\mathop{\\mathrm{int}}'],
	    exterior: ['\\mathop{\\mathrm{ext}}'],
	    volume: ['\\mathop{\\mathrm{vol}}'],

	    E: ['{\\rm I\\kern-.3em E}'],
	    Var: ['\\mathop{\\mathrm{Var}}'],
	    Cov: ['\\mathop{\\mathrm{Cov}}'],
	    Binom: ['\\mathop{\\mathrm{Binom}}'],
	    Exp: ['\\mathop{\\mathrm{Exp}}'],
	    Poi: ['\\mathop{\\mathrm{Poi}}'],

	    GL: ['\\mathrm{GL}'],
	    SL: ['\\mathrm{SL}'],
	    Aut: ['\\mathrm{Aut}'],
	    ker: ['\\mathrm{ker}'],
	    id: ['\\mathop{\\mathrm{id}}'],

	    Re: ['\\mathop{\\mathrm{Re}}'],
	    Im: ['\\mathop{\\mathrm{Im}}'],
	    Res: ['\\mathop{\\mathrm{Res}}'],
	}
    }
});


</script>

    <!-- Fathom - simple website analytics - https://github.com/usefathom/fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, '//stats.pierre.marijon.fr/tracker.js', 'fathom');
fathom('set', 'siteId', 'NYKUR');
fathom('trackPageview');
</script>
<!-- / Fathom -->



    
 <script data-isso="//isso.pierre.marijon.fr/" data-isso-reply-to-self="true" data-isso-require-author="true" data-isso-reveal-on-click="inf" src="https://isso.pierre.marijon.fr/js/embed.min.js"></script>

  </head>

  <body>

    <a href="https://github.com/natir/blog" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#485F41; color:#B6C8B1; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    
    <section class="page-header">
      <h1 class="project-name">Yet Another Bioinformatic blog</h1>
      <a class="btn" href="/">Home</a>
      <a class="btn" href="//pierre.marijon.fr">About</a>
      <a class="btn" href="/rss.xml">RSS feed</a>
    </section>


    <section class="main-content">
      
  <section class="post">
    <div class="title-and-info">
      <h1>Use misassemblies to compare noisy assembly</h1>
      <div class="info">
    	<span>13 minute read</span>
    	
    	<span class='divider'/>
    	<span>06 September 2019</span>
    	
    	
    	
      </div>
    </div>
    <article>
      <p>I think all the people who have ever done a genome assembly one day say: &quot;Ok my assembly was cool, but now how I can be sure it's the best and it didn't contain many errors ?&quot;</p>
<p>We have many technics to evaluate the quality of assembly (it isn't a complete review, sorry):</p>
<ul>
<li>with only assembly information:
<ul>
<li>with <a href="https://doi.org/10.1089/cmb.2017.0013">N50 family metrics</a></li>
<li>by analyse read remapping against assembly <a href="http://amos.sourceforge.net/wiki/index.php/Amosvalidate">ASMOValidate</a>, <a href="https://www.sanger.ac.uk/science/tools/reapr">REAPR</a>, <a href="https://github.com/vezzi/FRC_align">FRCbam</a>, <a href="https://github.com/broadinstitute/pilon/wiki">Pilon</a>, <a href="https://www.cbcb.umd.edu/software/valet">VALET</a></li>
<li>by computing the probability of the reads dataset that can be generate from the assembly (<a href="https://doi.org/10.1093/bioinformatics/bts723">ALE</a>, <a href="https://doi.org/10.1186/gb-2013-14-1-r8">CGAL</a>, <a href="https://doi.org/10.1186/1756-0500-6-334">LAP</a>)</li>
</ul>
</li>
<li>by using external information: 
<ul>
<li>count the number of core gene present in an assembly, <a href="https://busco.ezlab.org/">BUSCO</a></li>
<li>transcriptome information, <a href="https://doi.org/10.1186/gb-2009-10-4-r42">for example, <em>Bos taurus</em> genome validation</a></li>
<li>synteny information <a href="https://doi.org/10.1186/s12859-018-2026-4">Lui et al</a></li>
<li>map assembly against a near genome, <a href="https://doi.org/10.1093/bioinformatics/btt086">quast</a></li>
<li>map assembly against the reference genome</li>
</ul>
</li>
</ul>
<p>If you use quast to reference genome, you have already a reference genome, so why you want to perform an assembly?</p>
<p>The main case where we perform something like that was when we want to evaluate different assembly pipelines on the same read data set. To evaluate completely a new assembly pipeline, you have to test a different set of parameters, and evaluate the impact of adding or changing tools in an assembly pipeline.</p>
<p>Quast was a very useful tool and now they integrate many other assembly evaluating tools (BUSCO, <a href="http://exon.gatech.edu/GeneMark/">GeneMark</a>, <a href="https://doi.org/10.1093/bioinformatics/bth315">GlimmerHMM</a>, <a href="https://github.com/tseemann/barrnap">barnap</a>)</p>
<p>Recently, with Rayan Chikhi and Jean-Stéphane Varré, we publish a <a href="https://www.biorxiv.org/content/10.1101/674036v2">preprint</a> about <a href="https://github.com/natir/yacrd/">yacrd</a> and <a href="https://github.com/natir/fpa">fpa</a>, two standalone tools they can be introduced in assembly pipeline to remove very bad reads region and filter out low-quality overlap. We evaluate the effect of these tools on &quot;without correction long-reads assembly pipeline&quot; (<a href="https://github.com/lh3/miniasm">miniasm</a> and <a href="https://github.com/ruanjue/wtdbg2">redbean</a>) and compare the assembly quality of different pipeline with quast.</p>
<p>We send this paper to a journal, and a reviewer says something like &quot;quast isn't a good tool to evaluate high error assembly, the number of misassemblies was probably over evaluate.&quot; And it's probably true.</p>
<p>Miniasm and redbean perform an assembly without reads correction step (and without consensus step for miniasm). The low quality of the contigs sequence is a real problem: quast could confuse a low-quality region misaligned with misassemblies.</p>
<p>In this blog post, I want to answer the following questions:</p>
<ol>
<li>how to run quast on long-read uncorrected misassemblies</li>
<li>is the quast misassemblies count a good tool to evaluate / compare assemblies?</li>
<li>can we find better metrics than just a number of misassemblies?</li>
</ol>
<p>If you have no time to read all this long and technical details you can go directly to the <a href="https://blog.pierre.marijon.fr/long-read-misassemblies/#take-home-message">TL;DR</a>.</p>
<h2 id="dataset-assembly-pipeline-analysis-pipeline-her-version-and-parameter">Dataset, assembly pipeline, analysis pipeline her version and parameter</h2>
<p>For our test we are going to use two Nanopore datasets and one Pacbio dataset.</p>
<ul>
<li>Reads:
<ul>
<li><a href="https://www.ebi.ac.uk/ena/data/view/SRX3676783">Oxford nanopore D melanogaster</a> 63x</li>
<li><a href="http://s3.amazonaws.com/nanopore-human-wgs/chr1.sorted.bam">Oxford nanopore H sapiens chr1</a> 29x</li>
<li><a href="http://datasets.pacb.com.s3.amazonaws.com/2014/c_elegans/list.html">Pacbio RS P6-C4 C elegans</a> 80x</li>
</ul>
</li>
<li>References:
<ul>
<li><a href="https://www.ncbi.nlm.nih.gov/assembly/GCF_000001215.4">D. melanogaster</a> 143.726002 Mb</li>
<li><a href="ftp://ftp.ensembl.org/pub/release-95/fasta/caenorhabditis_elegans/dna/Caenorhabditis_elegans.WBcel235.dna.toplevel.fa.gz">C. elegans</a> 100.2 Mb</li>
<li><a href="ftp://ftp.ensembl.org/pub/release-95/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.chromosome.1.fa.gz">H. sapiens chr1</a> 248.9 Mb</li>
</ul>
</li>
</ul>
<p>To perform assembly we use minimap2 (version 2.16-r922) and miniasm (version 0.3-r179) with recommended preset for each sequencing technology (<code>ava-ont</code> and <code>ava-pb</code>).</p>
<p>We use <a href="https://github.com/lbcb-sci/racon">racon</a> (v1.4.3), for mapping read against assembly we use minimap2, with recommended preset for each sequencing technology.</p>
<p>We use quast version v5.0.2.</p>
<p>All dotplot was produced by <a href="http://dgenies.toulouse.inra.fr/">D-Genies</a>.</p>
<h2 id="quast-misassemblies-definition">Quast misassemblies definition</h2>
<p>What's a quast misassemblies? Did we have some different type? How they are defined? </p>
<p>Quast define three type of misassemblies <strong>relocation</strong>, <strong>translocation</strong> and <strong>inversion</strong>.</p>
<h3 id="relocation">Relocation</h3>
<p>A relocation can occur between two mappings of the same contigs against the same chromosome, we have two cases when these two mappings:</p>
<ul>
<li>is separated by a region without mapping (case <strong>A</strong>)</li>
<li>cover the same region of the chromosome  (case <strong>B</strong>)</li>
</ul>
<p><img src="https://blog.pierre.marijon.fr/long-read-misassemblies/relocation_def.svg" alt="relocation definition" /></p>
<p>A misassembly was count when $L_x$ and $L_z$ &gt; 1kbp (this value can't be change ?) and when $L_y$ &gt; <code>extensive-mis-size</code> (1kbp by default).</p>
<p>We can call $L_y$ the length of the relocations, it's a part where assembly pipeline make an error we can quantify the length of this error. When it's a relocation where a part of the reference is missing in assembly (case <strong>A</strong>) this length is positive when it's a relocation where assembly contains a duplication of a region present one time in reference (case <strong>B</strong>) this length is negative.</p>
<p><img src="https://blog.pierre.marijon.fr/long-read-misassemblies/relocation_dotplot_exemple.svg" alt="relocation dotplot exemple" /></p>
<p>A dotplot of contigs ctg000002L for our <em>C. elegans</em> miniasm assembly against the chromosome V, we can see two relocation events of type <strong>B</strong> circle in blue and a relocation event of type <strong>A</strong>, I have no idea to explain the other problem upper.</p>
<h3 id="translocation">Translocation</h3>
<p>A translocation occurs when contig has mapping on more than one reference chromosomes.</p>
<p><img src="https://blog.pierre.marijon.fr/long-read-misassemblies/translocation_def.svg" alt="translocation definition" /></p>
<p>Generally, it's easy to spot this type of misassemblies on dotplot, the contig has a match on two chromosomes.</p>
<p><img src="https://blog.pierre.marijon.fr/long-read-misassemblies/translocation_dotplot_exemple.svg" alt="translocation dotplot exemple" /></p>
<p>A part utg16L from our <em>C. elegans</em> miniasm assembly, map on chromosome II and V of reference, these contigs contain a translocation without any doubt. </p>
<h3 id="inversion">Inversion</h3>
<p>An inversion occurs when contig has two consecutive mappings on the same chromosome but in different strands.</p>
<p><img src="https://blog.pierre.marijon.fr/long-read-misassemblies/inversion_def.svg" alt="inversion definition" /></p>
<p>An inversion observes in dotplot of reference genome against miniasm assembly of <em>C. elegans</em></p>
<p><img src="https://blog.pierre.marijon.fr/long-read-misassemblies/inversion_dotplot_exemple.svg" alt="inversion dotplot exemple" /></p>
<p>The contig utg0000021L map on chromosome I but contig contains an inversion in begin.</p>
<h3 id="important-point">Important point</h3>
<p>For more details on quast misassemblies definition, you can read this section <a href="http://quast.bioinf.spbau.ru/manual.html#misassemblies">3.1.1</a> and section <a href="http://quast.bioinf.spbau.ru/manual.html#sec3.1.2">3.1.2</a> of quast manual.</p>
<p>Quast base her misassemblies analysis by mapping contigs against a reference. To perform alignment recent version of quast use <a href="https://github.com/lh3/minimap2">minimap2</a>, with preset <code>-x asm20</code> <a href="https://github.com/ablab/quast/blob/b040cc9140c7630eea95f94cdda3b825cf4a22c3/quast_libs/ca_utils/align_contigs.py#L65">when min-identity is lower than 90%</a>. Alignment with identity lower than <code>min-identity</code> (95% by default, minimum 80%) are filtered by quast.</p>
<p><code>min-identity</code> was a very important parameter, to have misassemblies we need to have at minimum two mappings for a contig. If the second mapping has an identity under than <code>min-identity</code> threshold quast can't observe this misassembly. But even more, if we take another case with three mappings if the mapping in middle was lowest than the <code>min-identity</code> threshold and if the gap creates between two other mappings is larger than <code>extensize-mis-size</code> quast can count misassembly, where it's, isn't a misassembly.</p>
<p><strong><code>min-identity</code> and <code>extensize-mis-size</code> have an important impact on misassemblies detection what is the effect of the evolution of these two parametres on the number of misassemblies found by quast?</strong></p>
<h2 id="effect-of-min-identity">Effect of min-identity</h2>
<h3 id="low-min-identity-is-required-for-uncorrected-assembly">Low min-identity is required for uncorrected assembly</h3>
<p>Quast uses mapping with alignment identity upper than <code>min-identity</code>, what is the good value of this parameter for long-read uncorrected assembly.</p>
<p>File <code>contigs_reports/minimap_output/{output-name}.coords</code> in the fourth column contains the mapping quality. For each dataset, we extract this value and plot in a histogram.</p>
<script>
  var plotly_load;
  if (typeof plotly_load === "undefined") {
      console.log("load plotly");
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src = "https://cdn.plot.ly/plotly-latest.min.js";
      script.id = "plotly";
      document.getElementsByTagName("head")[0].appendChild(script);
      plotly_load = true;
  }
  else {
      var script = document.getElementById("plotly");
  }
  script.addEventListener('load', function() {
      var s2 = document.createElement("script");
//      s2.type = "text/javascript";
      s2.src = "mapping_identity.js";
      document.getElementsByTagName("head")[0].appendChild(s2);
  });
  console.log(script);
</script>
<div id="mapping_identity"></div>
<p>In the horizontal axis, we have the identity percent, in the vertical axis, we have the number of mappings in each bin.</p>
<p>The black line mark quast the default identity value threshold, we can see a majority of alignment was under this threshold for uncorrected dataset usage of <code>min-identity 80</code> seems necessary.</p>
<h3 id="effect-on-a-corrected-dataset">Effect on a corrected dataset</h3>
<p>To test the effect of correction on misassemblies count we run racon 3 times on <em>C. elegans</em> (the one with the best reference) dataset.</p>
<p>For not corrected assembly quast use 7049 mapping, for corrected assembly quast use 30931 (increasing ratio 4.38).</p>
<script>
  var plotly_load;
  if (typeof plotly_load === "undefined") {
      console.log("load plotly");
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src = "https://cdn.plot.ly/plotly-latest.min.js";
      script.id = "plotly";
      document.getElementsByTagName("head")[0].appendChild(script);
      plotly_load = true;
  }
  else {
      var script = document.getElementById("plotly");
  }
  script.addEventListener('load', function() {
      var s2 = document.createElement("script");
//      s2.type = "text/javascript";
      s2.src = "c_elegans_map_id.js";
      document.getElementsByTagName("head")[0].appendChild(s2);
  });
  console.log(script);
</script>
<div id="c_elegans_map_id"></div>
<p>In the horizontal axis, we have the identity percent, in the vertical axis, we have the number of mappings in each bin.</p>
<p>We can observe an increase in mapping quality, a majority of mapping has an identity upper than 95 % compared to the uncorrected assembly.</p>
<p>To have an insight on the effect of mapping_identity on corrected assembly we run quast with default parameter on corrected (with racon) <em>C. elegans</em> dataset.</p>
<table><thead><tr><th>racon</th><th>no</th><th>yes</th><th>yes</th></tr></thead><tbody>
<tr><td><strong>min-identity</strong></td><td><strong>80</strong></td><td><strong>80</strong></td><td><strong>95</strong></td></tr>
<tr><td>relocation</td><td>1131</td><td>886</td><td>635</td></tr>
<tr><td>translocation</td><td>200</td><td>259</td><td>170</td></tr>
<tr><td>inversion</td><td>65</td><td>68</td><td>75</td></tr>
<tr><td>total</td><td>1396</td><td>1213</td><td>880</td></tr>
</tbody></table>
<p>With <code>min-identity 80</code> the number of relocation and translocation is increased compared to the default value of <code>min-identity</code>. If quast have only one alignment of a contig, quast can't found misassemblies, by reducing the <code>min-identity</code> we increase the number of alignment and mechanically increase the number of misassemblies.</p>
<p>Maybe some of these misassemblies aren't real misassemblies but if we use the same <code>min-identity</code> value for all assembly we want to compare. We can hope this number of fake misassemblies was the same in all conditions.</p>
<p><strong>For an uncorrected long-read misassemblies use the minimal identity threshold (80 %) was required</strong></p>
<h2 id="effect-of-extensive-min-size-on-misassemblies-count">Effect of extensive-min-size on misassemblies count</h2>
<p>We observe the <code>min-identity</code> parameter have a very important impact on the number of misassemblies and for uncorrected long-read assembly we need to set this parameter to 80 %. Now we want to observe what is the impact of <code>extensive-min-size</code> parameter.</p>
<p>We launch quast with different value for parameter <code>extensive-min-size</code> 1.000, 2.000, 3.000, 4.000, 5.000, 6.000, 7.000, 8.000, 9.000, 10.000, 20.000, 30.000, 40.000, 50.0000 the parameter <code>min-identity</code> was fix at 80 %.</p>
<script>
  var plotly_load;
  if (typeof plotly_load === "undefined") {
      console.log("load plotly");
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src = "https://cdn.plot.ly/plotly-latest.min.js";
      script.id = "plotly";
      document.getElementsByTagName("head")[0].appendChild(script);
      plotly_load = true;
  }
  else {
      var script = document.getElementById("plotly");
  }
  script.addEventListener('load', function() {
      var s2 = document.createElement("script");
//      s2.type = "text/javascript";
      s2.src = "nb_breakpoint.js";
      document.getElementsByTagName("head")[0].appendChild(s2);
  });
  console.log(script);
</script>
<div id="nb_breakpoint"></div>
<p>In the horizontal axis, we have the <code>extensive-min-size</code> value in the vertical axis we have the number of misassemblies, you can click on the legend to show or hide an element.</p>
<p>This graph shows the evolution of the number of misassemblies in the function of the <code>extensive-min-size</code> value, after 10.000 the number of misassemblies becomes quite stable.</p>
<p>This graph shows two types of misassemblies some found with <code>extensive-min-size</code> lower than 10.000 and another where <code>extensive-min-size</code> are upper than 10.000. <strong>This information was intresting but we know quast have three type of misassemblies and only relocation was affect by <code>extensive-min-size</code> parameter. How each type evolve when this parameter grow</strong></p>
<h3 id="effect-of-extensive-min-size-on-each-misassemblies-types-count">Effect of extensive-min-size on each misassemblies types count</h3>
<p>Quast defines three types of misassemblies <strong>relocation</strong>, <strong>translocation</strong> and <strong>inversion</strong> previously we observe the total number of misassemblies, how each group of misassembly evolves.</p>
<script>
  var plotly_load;
  if (typeof plotly_load === "undefined") {
      console.log("load plotly");
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src = "https://cdn.plot.ly/plotly-latest.min.js";
      script.id = "plotly";
      document.getElementsByTagName("head")[0].appendChild(script);
      plotly_load = true;
  }
  else {
      var script = document.getElementById("plotly");
  }
  script.addEventListener('load', function() {
      var s2 = document.createElement("script");
//      s2.type = "text/javascript";
      s2.src = "misassemblies_type.js";
      document.getElementsByTagName("head")[0].appendChild(s2);
  });
  console.log(script);
</script>
<div id="misassemblies_type"></div>
<p>In the horizontal axis, we have the <code>extensive-min-size</code> value in the vertical axis, we have the number of misassemblies, you can click on the legend to show or hide an element.</p>
<p>For <em>H. sapiens</em> dataset didn't have any translocation because the reference was composed of only one chromosome, the majority of misassemblies were relocation but when we increase the parameter extensive-min-size the number of inversions was increasing.</p>
<p><em>D. melanogaster</em> reference contains many small contigs this can explain the high number of translocation. Relocation and translocation drop at the same time. </p>
<p>For <em>C. elegans</em> the number of translocations was quite stable, the number of relocations drops down rapidly and the inversion has a little increase.</p>
<p>I can't explain why translocation and inversion number change with a different value of <code>extensive-min-size</code>. By reading quast documentation and code I didn't understand the influence of this parameter on this group of misassemblies.</p>
<p><strong>Relocation misassemblies are the most common type of misassemblies and we can impute the reduction of misassemblies, when <code>extensive-min-size</code> grow up, to relocation misassemblies reduction.</strong></p>
<h3 id="relocation-length-distribution">Relocation length distribution</h3>
<p>We see previously for our assemblies a majority of misassemblies were relocation we are now focused on this type of misassemblies. For each relocation we can attach a length, this length was the length of incongruence between assembly and reference genome, it's equal to $L_y$.</p>
<p>The file <code>{quast_output}/contigs_reports/all_alignements_{assembly_file_name}.tsv</code> contains information about mapping and misassemblies. For other information on how quast store mapping and misassemblies information read <a href="http://quast.bioinf.spbau.ru/manual.html#sec7">quast faq</a>.</p>
<p><img src="https://blog.pierre.marijon.fr/long-read-misassemblies/relocation_length.svg" alt="relocation_length.svg" /></p>
<p>In the horizontal axis, we have the log length of each relocation, in the vertical axis, we have the species, orange point for negative relocation, green point for positive relocation.</p>
<p>This figure shows a swarm plot of log of length associated to recombination it's the size of the gap between mapping border the misassemblies. If the length is positive assembly miss a part of the reference (green point) if the length is negative assembly duplicate a part of the reference (orange point), <a href="https://blog.pierre.marijon.fr/long-read-misassemblies/relocation_length.py">source code</a>, <a href="https://blog.pierre.marijon.fr/long-read-misassemblies/relocation_length.csv">data</a> and data was available.</p>
<p>For <em>H. sapiens</em> majority of relocation was positive and short (between 1000 and 5000 base), with some very large relocation. For <em>C. elegans</em> it's different, the majority of relocation is negative and the largest relocation was shortest than <em>H. sapiens</em>. For <em>D. melanogaster</em> the size of relocations was more spread the majority of relocation isn't the shortest this confirmed by the appearance of the curve seen in the previous part when the <code>extensize-min-size</code> is increased, the number of relocations decreases less quickly than for the other datasets. </p>
<p><strong>With this representation, we can analyze the difference between relocation distribution in term of the number of relocation and her length distribution.</strong></p>
<h2 id="conclusion">Conclusion</h2>
<p>If you work with quast to evaluate an uncorrected misassembly, you need to set <code>min-identity</code> parameter to 80 %. It would be nice to have a lower minimum value, maybe 70%, but the quast code would have to be modified. And this value is required only for miniasm assembly, for tools with a better consensus step (redbean for exemple) 80 % was suffisent.</p>
<p>The translocation and inversion was the minority of misassemblies but when they occure the are clearly a misassemblies. I would be very surprised to see a translocation or inversion created by a mapping error generated by errors in uncorrected reads. We can use the count of translocation and inversion.</p>
<p>For relocations, the majority of misassemblies in our case, some of them are <em>true</em> some of them are  <em>false</em>, check all misassemblies manualy is impossible, found the good <code>extensive-min-size</code> value seems very hard for me. The easiest think we can do is compare the series of length associate to relocation in this blogpost I use a swarmplot I think statisticien people could find better tools.</p>
<h2 id="take-home-message">Take home message</h2>
<p>You can use quast to compare long-read uncorrected misassemblies but:</p>
<ul>
<li>run quast with <code>--min-identity 80</code></li>
<li>compare translocation and inversion count</li>
<li>for relocation compare distribution of length associate to each misassemblies</li>
</ul>
<h2 id="acknowledgement">Acknowledgement</h2>
<p>For their help in writing this blogpost:</p>
<ul>
<li>Rayan Chikhi</li>
<li>Jean-Stéphane Varré</li>
<li>Yoann Dufresne</li>
<li>Antoine Limasset</li>
<li>Matthieu Falce</li>
<li>Kevin Gueuti</li>
</ul>

    </article>
  </section>

  <h2>Comments:</h2>
    <section id="isso-thread"></section>
    
      <footer class="site-footer">
	<span class="site-footer-credits">
	  <center>
	    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
	      <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" />
	    </a>
	  </center>
	  <br />
	  <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Yet Another Bioinformatic blog</span> by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Pierre Marijon</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.<br />Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href=https:&#x2F;&#x2F;blog.pierre.marijon.fr&#x2F;long-read-misassemblies&#x2F; rel="dct:source">blog.pierre.marijon.fr</a>.</span>
      </footer>
    </section>
    

    
<section class="share-page">
  Share this on &rarr; <br/>
  <a href="https://twitter.com/intent/tweet?text=Use misassemblies to compare noisy assembly&url=https:&#x2F;&#x2F;blog.pierre.marijon.fr&#x2F;long-read-misassemblies&#x2F;&via=pierre_marijon&related=pierre_marijon" rel="nofollow" target="_blank" title="Share on Twitter">
    <span class="fa fa-twitter fa-3x"></span>
  </a>
  <a href="http://www.linkedin.com/shareArticle?mini=true&url=https:&#x2F;&#x2F;blog.pierre.marijon.fr&#x2F;long-read-misassemblies&#x2F; &title=Use misassemblies to compare noisy assembly&source=https:&#x2F;&#x2F;blog.pierre.marijon.fr">
    <span class="fa fa-linkedin fa-3x"></span>
  </a>
</section> 


  </body>
</html>
